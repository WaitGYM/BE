// src/routes/waiting.js - Ïã§ÏãúÍ∞Ñ ETAÏôÄ WebSocketÏù¥ ÌÜµÌï©Îêú ÏµúÏ¢Ö Î≤ÑÏ†Ñ

const router = require('express').Router()
const { PrismaClient } = require('@prisma/client')
const { auth } = require('../middleware/auth')
const { 
  sendNotification, 
  broadcastETAUpdate, 
  broadcastEquipmentStatusChange 
} = require('../websocket')
const { z } = require('zod')

const prisma = new PrismaClient()

// ====== Ïä§Ìå∏ Î∞©ÏßÄ ÏãúÏä§ÌÖú ======
const userUpdateLimiter = new Map()
const RATE_LIMIT = {
  WINDOW_MS: 60 * 1000,
  MAX_REQUESTS: 3,
  COOLDOWN_MS: 10 * 1000
}

function checkRateLimit(userId) {
  const now = Date.now()
  const userLimit = userUpdateLimiter.get(userId)
  
  if (!userLimit) {
    userUpdateLimiter.set(userId, { lastUpdate: now, requestCount: 1 })
    return { allowed: true }
  }
  
  if (now - userLimit.lastUpdate > RATE_LIMIT.WINDOW_MS) {
    userUpdateLimiter.set(userId, { lastUpdate: now, requestCount: 1 })
    return { allowed: true }
  }
  
  if (now - userLimit.lastUpdate < RATE_LIMIT.COOLDOWN_MS) {
    return { 
      allowed: false, 
      remainingMs: RATE_LIMIT.COOLDOWN_MS - (now - userLimit.lastUpdate),
      reason: 'cooldown'
    }
  }
  
  if (userLimit.requestCount >= RATE_LIMIT.MAX_REQUESTS) {
    return { 
      allowed: false, 
      remainingMs: RATE_LIMIT.WINDOW_MS - (now - userLimit.lastUpdate),
      reason: 'rate_limit'
    }
  }
  
  userLimit.requestCount++
  userLimit.lastUpdate = now
  return { allowed: true }
}

// ====== ETA Í≥ÑÏÇ∞ ======
const AVG_SET_MIN = 3
const SETUP_CLEANUP_MIN = 1

function calculateRealTimeETA(usage) {
  if (!usage || usage.status !== 'IN_USE') return 0
  
  const now = Date.now()
  const setMs = AVG_SET_MIN * 60 * 1000
  const restMs = (usage.restSeconds || 0) * 1000
  const remainingSets = Math.max(0, usage.totalSets - usage.currentSet + 1)
  
  if (usage.setStatus === 'EXERCISING') {
    const currentSetElapsed = usage.currentSetStartedAt ? 
      now - usage.currentSetStartedAt.getTime() : 0
    const currentSetRemaining = Math.max(0, setMs - currentSetElapsed)
    const futureWorkTime = (remainingSets - 1) * setMs
    const futureRestTime = (remainingSets - 1) * restMs
    
    return Math.ceil((currentSetRemaining + futureWorkTime + futureRestTime) / 60000)
  }
  
  if (usage.setStatus === 'RESTING') {
    const restElapsed = usage.restStartedAt ? 
      now - usage.restStartedAt.getTime() : 0
    const restRemaining = Math.max(0, restMs - restElapsed)
    const futureWorkTime = remainingSets * setMs
    const futureRestTime = (remainingSets - 1) * restMs
    
    return Math.ceil((restRemaining + futureWorkTime + futureRestTime) / 60000)
  }
  
  return 0
}

function buildQueueETAs(currentETA, queue) {
  const etas = []
  let accumulator = currentETA + SETUP_CLEANUP_MIN
  
  for (let i = 0; i < queue.length; i++) {
    etas.push(accumulator)
    accumulator += AVG_SET_MIN * 3 + 2 + SETUP_CLEANUP_MIN
  }
  
  return etas
}

// ====== ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏä§ÌÖú ======
let autoUpdateIntervals = new Map()

async function startAutoUpdate(equipmentId) {
  if (autoUpdateIntervals.has(equipmentId)) return
  
  const intervalId = setInterval(async () => {
    try {
      const currentUsage = await prisma.equipmentUsage.findFirst({
        where: { equipmentId, status: 'IN_USE' },
        include: { user: { select: { name: true } }, equipment: true }
      })
      
      if (!currentUsage) {
        stopAutoUpdate(equipmentId)
        return
      }
      
      const queue = await prisma.waitingQueue.findMany({
        where: { equipmentId, status: { in: ['WAITING', 'NOTIFIED'] } },
        orderBy: { queuePosition: 'asc' },
        include: { user: { select: { name: true } } }
      })
      
      if (queue.length === 0) {
        stopAutoUpdate(equipmentId)
        return
      }
      
      const currentETA = calculateRealTimeETA(currentUsage)
      const queueETAs = buildQueueETAs(currentETA, queue)
      
      // üî• WebSocketÏúºÎ°ú Ïã§ÏãúÍ∞Ñ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
      const updateData = {
        equipmentId,
        equipmentName: currentUsage.equipment.name,
        currentUsage: {
          userName: currentUsage.user.name,
          totalSets: currentUsage.totalSets,
          currentSet: currentUsage.currentSet,
          setStatus: currentUsage.setStatus,
          estimatedMinutesLeft: currentETA,
          progress: Math.round((currentUsage.currentSet / currentUsage.totalSets) * 100)
        },
        waitingQueue: queue.map((q, index) => ({
          id: q.id,
          position: q.queuePosition,
          userName: q.user.name,
          estimatedWaitMinutes: queueETAs[index]
        })),
        lastUpdated: new Date(),
        isAutoUpdate: true
      }
      
      // Í∏∞Íµ¨ Íµ¨ÎèÖÏûêÎì§ÏóêÍ≤å Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
      broadcastETAUpdate(equipmentId, updateData)
      
      // Í∞úÎ≥Ñ ÏÇ¨Ïö©ÏûêÏóêÍ≤åÎèÑ ÏïåÎ¶º
      queue.forEach((q, index) => {
        sendNotification(q.userId, {
          type: 'AUTO_ETA_UPDATE',
          title: 'ETA ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏',
          message: `${currentUsage.equipment.name} ÏòàÏÉÅ ÎåÄÍ∏∞ÏãúÍ∞Ñ: ${queueETAs[index]}Î∂Ñ`,
          equipmentId,
          estimatedWaitMinutes: queueETAs[index],
          queuePosition: q.queuePosition
        })
      })
      
    } catch (error) {
      console.error('ÏûêÎèô ETA ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', error)
      stopAutoUpdate(equipmentId)
    }
  }, 2 * 60 * 1000) // 2Î∂ÑÎßàÎã§
  
  autoUpdateIntervals.set(equipmentId, intervalId)
  console.log(`ÏûêÎèô ETA ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë: Í∏∞Íµ¨ ${equipmentId}`)
}

function stopAutoUpdate(equipmentId) {
  const intervalId = autoUpdateIntervals.get(equipmentId)
  if (intervalId) {
    clearInterval(intervalId)
    autoUpdateIntervals.delete(equipmentId)
    console.log(`ÏûêÎèô ETA ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ: Í∏∞Íµ¨ ${equipmentId}`)
  }
}

// ====== API ÏóîÎìúÌè¨Ïù∏Ìä∏Îì§ ======

// üî• ETA ÏàòÎèô ÏóÖÎç∞Ïù¥Ìä∏ API
router.post('/update-eta/:equipmentId', auth(), async (req, res) => {
  try {
    const equipmentId = parseInt(req.params.equipmentId)
    const userId = req.user.id
    
    // Ïä§Ìå∏ Î∞©ÏßÄ Ï≤¥ÌÅ¨
    const rateLimitCheck = checkRateLimit(userId)
    if (!rateLimitCheck.allowed) {
      const remainingSec = Math.ceil(rateLimitCheck.remainingMs / 1000)
      return res.status(429).json({ 
        error: rateLimitCheck.reason === 'cooldown' ? 'ÎÑàÎ¨¥ ÏûêÏ£º ÏóÖÎç∞Ïù¥Ìä∏ÌñàÏäµÎãàÎã§' : 'ÏóÖÎç∞Ïù¥Ìä∏ ÌöüÏàò Ï¥àÍ≥º',
        remainingSeconds: remainingSec,
        message: `${remainingSec}Ï¥à ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî`
      })
    }
    
    const equipment = await prisma.equipment.findUnique({
      where: { id: equipmentId }
    })
    if (!equipment) {
      return res.status(404).json({ error: 'Í∏∞Íµ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§' })
    }
    
    const currentUsage = await prisma.equipmentUsage.findFirst({
      where: { equipmentId, status: 'IN_USE' },
      include: { user: { select: { name: true } } }
    })
    
    const queue = await prisma.waitingQueue.findMany({
      where: { equipmentId, status: { in: ['WAITING', 'NOTIFIED'] } },
      orderBy: { queuePosition: 'asc' },
      include: { user: { select: { name: true } } }
    })
    
    const currentETA = currentUsage ? calculateRealTimeETA(currentUsage) : 0
    const queueETAs = buildQueueETAs(currentETA, queue)
    const updateTime = new Date()
    
    // üî• Ïã§ÏãúÍ∞Ñ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
    const updateData = {
      equipmentId,
      equipmentName: equipment.name,
      updatedAt: updateTime,
      updatedBy: userId,
      currentUsage: currentUsage ? {
        userName: currentUsage.user.name,
        totalSets: currentUsage.totalSets,
        currentSet: currentUsage.currentSet,
        setStatus: currentUsage.setStatus,
        estimatedMinutesLeft: currentETA,
        progress: Math.round((currentUsage.currentSet / currentUsage.totalSets) * 100)
      } : null,
      waitingQueue: queue.map((q, index) => ({
        id: q.id,
        position: q.queuePosition,
        userName: q.user.name,
        estimatedWaitMinutes: queueETAs[index],
        isYou: q.userId === userId
      })),
      totalWaiting: queue.length,
      isManualUpdate: true
    }
    
    // WebSocket Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
    broadcastETAUpdate(equipmentId, updateData)
    
    // ÎåÄÍ∏∞ Ï§ëÏù∏ Î™®Îì† ÏÇ¨Ïö©ÏûêÏóêÍ≤å Í∞úÎ≥Ñ ÏïåÎ¶º
    queue.forEach((q, index) => {
      sendNotification(q.userId, {
        type: 'ETA_UPDATED',
        title: 'ETA ÏóÖÎç∞Ïù¥Ìä∏',
        message: `${equipment.name} ÏòàÏÉÅ ÎåÄÍ∏∞ÏãúÍ∞Ñ: ${queueETAs[index]}Î∂Ñ`,
        equipmentId,
        equipmentName: equipment.name,
        estimatedWaitMinutes: queueETAs[index],
        queuePosition: q.queuePosition,
        updatedAt: updateTime,
        updatedBy: q.userId === userId ? 'ÎÇò' : 'Îã§Î•∏ ÏÇ¨Ïö©Ïûê'
      })
    })
    
    res.json(updateData)
    
  } catch (error) {
    console.error('ETA ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:', error)
    res.status(500).json({ error: 'ETA ÏóÖÎç∞Ïù¥Ìä∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§' })
  }
})

// üî• Í∏∞Íµ¨ ÏÇ¨Ïö© ÏãúÏûë API (ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ Ìè¨Ìï®)
router.post('/start-using/:equipmentId', auth(), async (req, res) => {
  try {
    const equipmentId = parseInt(req.params.equipmentId)
    const { totalSets = 3, restSeconds = 180 } = req.body
    
    const equipment = await prisma.equipment.findUnique({ where: { id: equipmentId } })
    if (!equipment) return res.status(404).json({ error: 'Í∏∞Íµ¨ ÏóÜÏùå' })

    const currentUsage = await prisma.equipmentUsage.findFirst({
      where: { equipmentId, status: 'IN_USE' }, include: { user: true }
    })
    if (currentUsage) {
      return res.status(409).json({ 
        error: 'Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ë', 
        currentUser: currentUsage.user.name, 
        since: currentUsage.startedAt 
      })
    }

    const myUsage = await prisma.equipmentUsage.findFirst({
      where: { userId: req.user.id, status: 'IN_USE' }, 
      include: { equipment: true }
    })
    if (myUsage) {
      return res.status(409).json({ 
        error: 'Îã§Î•∏ Í∏∞Íµ¨ ÏÇ¨Ïö© Ï§ë', 
        currentEquipment: myUsage.equipment.name, 
        equipmentId: myUsage.equipmentId 
      })
    }

    const firstInQueue = await prisma.waitingQueue.findFirst({
      where: { equipmentId, status: { in: ['WAITING', 'NOTIFIED'] } }, 
      orderBy: { queuePosition: 'asc' }
    })
    
    if (firstInQueue && firstInQueue.userId !== req.user.id) {
      return res.status(403).json({ 
        error: 'ÎåÄÍ∏∞ ÏàúÏÑúÍ∞Ä ÏïÑÎãò', 
        firstPosition: firstInQueue.queuePosition 
      })
    }

    const usage = await prisma.$transaction(async (tx) => {
      const u = await tx.equipmentUsage.create({
        data: {
          equipmentId,
          userId: req.user.id,
          totalSets,
          currentSet: 1,
          restSeconds,
          status: 'IN_USE',
          setStatus: 'EXERCISING',
          currentSetStartedAt: new Date(),
          estimatedEndAt: new Date(Date.now() + ((totalSets * 5 * 60) + ((totalSets - 1) * restSeconds)) * 1000),
        },
        include: { equipment: true, user: { select: { name: true } } }
      })
      
      if (firstInQueue && firstInQueue.userId === req.user.id) {
        await tx.waitingQueue.update({ 
          where: { id: firstInQueue.id }, 
          data: { status: 'COMPLETED' } 
        })
      }
      
      return u
    })

    // üî• ÏÉÅÌÉú Î≥ÄÍ≤Ω Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
    broadcastEquipmentStatusChange(equipmentId, {
      type: 'usage_started',
      equipmentName: equipment.name,
      userName: usage.user.name,
      totalSets: usage.totalSets,
      startedAt: usage.startedAt
    })

    // üî• ÏûêÎèô ETA ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë
    startAutoUpdate(equipmentId)

    res.status(201).json({
      id: usage.id,
      equipmentId: usage.equipmentId,
      equipmentName: usage.equipment.name,
      totalSets: usage.totalSets,
      currentSet: usage.currentSet,
      setStatus: usage.setStatus,
      restSeconds: usage.restSeconds,
      startedAt: usage.startedAt,
      estimatedEndAt: usage.estimatedEndAt,
      progress: Math.round((usage.currentSet / usage.totalSets) * 100)
    })
    
  } catch (error) {
    console.error('start-using error:', error)
    res.status(500).json({ error: 'Í∏∞Íµ¨ ÏÇ¨Ïö© ÏãúÏûë Ïã§Ìå®' })
  }
})

// üî• ÏÑ∏Ìä∏ ÏôÑÎ£å API (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ìè¨Ìï®)
router.post('/complete-set/:equipmentId', auth(), async (req, res) => {
  try {
    const equipmentId = parseInt(req.params.equipmentId)
    const usage = await prisma.equipmentUsage.findFirst({
      where: { equipmentId, userId: req.user.id, status: 'IN_USE' }, 
      include: { equipment: true, user: { select: { name: true } } }
    })
    
    if (!usage) return res.status(404).json({ error: 'ÏÇ¨Ïö© Ï§ë ÏïÑÎãò' })
    if (usage.setStatus !== 'EXERCISING') {
      return res.status(400).json({ 
        error: 'EXERCISING ÏÉÅÌÉúÍ∞Ä ÏïÑÎãò', 
        currentStatus: usage.setStatus 
      })
    }

    const isLastSet = usage.currentSet >= usage.totalSets
    
    if (isLastSet) {
      // Ïö¥Îèô ÏôÑÎ£å
      await prisma.equipmentUsage.update({
        where: { id: usage.id }, 
        data: { 
          status: 'COMPLETED', 
          setStatus: 'COMPLETED', 
          endedAt: new Date() 
        }
      })
      
      // üî• ÏôÑÎ£å Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
      broadcastEquipmentStatusChange(equipmentId, {
        type: 'usage_completed',
        equipmentName: usage.equipment.name,
        userName: usage.user.name,
        totalSets: usage.totalSets,
        completedAt: new Date()
      })
      
      // ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ
      stopAutoUpdate(equipmentId)
      
      // Îã§Ïùå ÎåÄÍ∏∞Ïûê ÏïåÎ¶º
      setTimeout(() => notifyNextUser(equipmentId), 1000)
      
      return res.json({ 
        message: `Ï†ÑÏ≤¥ ${usage.totalSets}ÏÑ∏Ìä∏ ÏôÑÎ£å!`, 
        completed: true 
      })
    }

    // Ìú¥Ïãù ÏãúÏûë
    await prisma.equipmentUsage.update({
      where: { id: usage.id }, 
      data: { 
        setStatus: 'RESTING', 
        restStartedAt: new Date() 
      }
    })

    // üî• Ìú¥Ïãù ÏãúÏûë Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
    broadcastEquipmentStatusChange(equipmentId, {
      type: 'rest_started',
      equipmentName: usage.equipment.name,
      userName: usage.user.name,
      currentSet: usage.currentSet,
      totalSets: usage.totalSets,
      restSeconds: usage.restSeconds
    })

    // Ìú¥Ïãù ÏïåÎ¶º
    sendNotification(req.user.id, {
      type: 'REST_STARTED',
      title: 'Ìú¥Ïãù ÏãúÏûë',
      message: `${usage.currentSet}/${usage.totalSets} ÏÑ∏Ìä∏ ÏôÑÎ£å`,
      equipmentId,
      restSeconds: usage.restSeconds
    })

    // ÏûêÎèô Îã§Ïùå ÏÑ∏Ìä∏ ÏãúÏûë
    if (usage.restSeconds > 0) {
      setTimeout(async () => {
        const current = await prisma.equipmentUsage.findUnique({ 
          where: { id: usage.id }, 
          include: { equipment: true, user: { select: { name: true } } } 
        })
        
        if (current && current.setStatus === 'RESTING' && current.status === 'IN_USE') {
          await prisma.equipmentUsage.update({
            where: { id: usage.id },
            data: { 
              currentSet: current.currentSet + 1, 
              setStatus: 'EXERCISING', 
              currentSetStartedAt: new Date(), 
              restStartedAt: null 
            }
          })
          
          // üî• Îã§Ïùå ÏÑ∏Ìä∏ ÏãúÏûë Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
          broadcastEquipmentStatusChange(equipmentId, {
            type: 'next_set_started',
            equipmentName: current.equipment.name,
            userName: current.user.name,
            currentSet: current.currentSet + 1,
            totalSets: current.totalSets
          })
          
          sendNotification(req.user.id, {
            type: 'NEXT_SET_STARTED',
            title: 'Îã§Ïùå ÏÑ∏Ìä∏',
            message: `${current.currentSet + 1}/${current.totalSets} ÏÑ∏Ìä∏ ÏãúÏûë`,
            equipmentId
          })
        }
      }, usage.restSeconds * 1000)
    }

    res.json({ 
      message: `${usage.currentSet}/${usage.totalSets} ÏÑ∏Ìä∏ ÏôÑÎ£å`, 
      setStatus: 'RESTING',
      restSeconds: usage.restSeconds
    })
    
  } catch (error) {
    console.error('complete-set error:', error)
    res.status(500).json({ error: 'ÏÑ∏Ìä∏ ÏôÑÎ£å Ïã§Ìå®' })
  }
})

// üî• Ïö¥Îèô Ï§ëÎã® API (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ìè¨Ìï®)
router.post('/stop-exercise/:equipmentId', auth(), async (req, res) => {
  try {
    const equipmentId = parseInt(req.params.equipmentId)
    const usage = await prisma.equipmentUsage.findFirst({
      where: { equipmentId, userId: req.user.id, status: 'IN_USE' }, 
      include: { equipment: true, user: { select: { name: true } } }
    })
    
    if (!usage) return res.status(404).json({ error: 'ÏÇ¨Ïö© Ï§ë ÏïÑÎãò' })

    await prisma.equipmentUsage.update({
      where: { id: usage.id }, 
      data: { 
        status: 'COMPLETED', 
        setStatus: 'STOPPED', 
        endedAt: new Date() 
      }
    })
    
    // üî• Ï§ëÎã® Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
    broadcastEquipmentStatusChange(equipmentId, {
      type: 'usage_stopped',
      equipmentName: usage.equipment.name,
      userName: usage.user.name,
      completedSets: usage.currentSet,
      totalSets: usage.totalSets,
      stoppedAt: new Date()
    })
    
    sendNotification(req.user.id, {
      type: 'EXERCISE_STOPPED',
      title: 'Ïö¥Îèô Ï§ëÎã®',
      message: `${usage.equipment.name} Ïö¥Îèô Ï§ëÎã®`,
      equipmentId
    })
    
    // ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÏßÄ Î∞è Îã§Ïùå ÏÇ¨Ïö©Ïûê ÏïåÎ¶º
    stopAutoUpdate(equipmentId)
    setTimeout(() => notifyNextUser(equipmentId), 1000)

    res.json({ message: 'Ïö¥Îèô Ï§ëÎã® ÏôÑÎ£å' })
    
  } catch (error) {
    console.error('stop-exercise error:', error)
    res.status(500).json({ error: 'Ïö¥Îèô Ï§ëÎã® Ïã§Ìå®' })
  }
})

// üî• ÎåÄÍ∏∞Ïó¥ Îì±Î°ù API (Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ìè¨Ìï®)
router.post('/queue/:equipmentId', auth(), async (req, res) => {
  try {
    const equipmentId = parseInt(req.params.equipmentId)
    const equipment = await prisma.equipment.findUnique({ where: { id: equipmentId } })
    if (!equipment) return res.status(404).json({ error: 'Í∏∞Íµ¨ ÏóÜÏùå' })

    const existing = await prisma.waitingQueue.findFirst({
      where: { 
        equipmentId, 
        userId: req.user.id, 
        status: { in: ['WAITING', 'NOTIFIED'] } 
      }
    })
    
    if (existing) {
      return res.status(409).json({ 
        error: 'Ïù¥ÎØ∏ ÎåÄÍ∏∞Ïó¥ Îì±Î°ù', 
        queuePosition: existing.queuePosition, 
        status: existing.status 
      })
    }

    const myUsage = await prisma.equipmentUsage.findFirst({ 
      where: { userId: req.user.id, status: 'IN_USE' } 
    })
    if (myUsage) return res.status(409).json({ error: 'Ïù¥ÎØ∏ Îã§Î•∏ Í∏∞Íµ¨ ÏÇ¨Ïö© Ï§ë' })

    const length = await prisma.waitingQueue.count({
      where: { equipmentId, status: { in: ['WAITING', 'NOTIFIED'] } }
    })
    
    const queue = await prisma.waitingQueue.create({
      data: { 
        equipmentId, 
        userId: req.user.id, 
        queuePosition: length + 1, 
        status: 'WAITING' 
      },
      include: { equipment: true, user: { select: { name: true } } }
    })

    // üî• ÎåÄÍ∏∞Ïó¥ Îì±Î°ù Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
    broadcastEquipmentStatusChange(equipmentId, {
      type: 'queue_joined',
      equipmentName: equipment.name,
      userName: queue.user.name,
      queuePosition: queue.queuePosition,
      totalWaiting: length + 1
    })

    // Ï¶âÏãú ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Í≤ΩÏö∞ ÏïåÎ¶º
    const currentUsage = await prisma.equipmentUsage.findFirst({ 
      where: { equipmentId, status: 'IN_USE' } 
    })
    
    if (!currentUsage && queue.queuePosition === 1) {
      setTimeout(() => notifyNextUser(equipmentId), 1000)
    } else if (currentUsage) {
      // ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë (ÏïÑÏßÅ ÏãúÏûëÎêòÏßÄ ÏïäÏïòÎã§Î©¥)
      startAutoUpdate(equipmentId)
    }

    res.status(201).json({
      id: queue.id,
      queuePosition: queue.queuePosition,
      equipmentId,
      equipmentName: queue.equipment.name,
      status: queue.status,
      estimatedWaitMinutes: length * 15 // Í∞ÑÎã®Ìïú ÏòàÏÉÅ ÏãúÍ∞Ñ
    })
    
  } catch (error) {
    console.error('queue add error:', error)
    res.status(500).json({ error: 'ÎåÄÍ∏∞Ïó¥ Îì±Î°ù Ïã§Ìå®' })
  }
})

// ====== Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§ ======

async function reorderQueue(equipmentId) {
  const rows = await prisma.waitingQueue.findMany({
    where: { equipmentId, status: { in: ['WAITING', 'NOTIFIED'] } },
    orderBy: { createdAt: 'asc' },
  })
  
  for (let i = 0; i < rows.length; i++) {
    if (rows[i].queuePosition !== i + 1) {
      await prisma.waitingQueue.update({
        where: { id: rows[i].id },
        data: { queuePosition: i + 1 },
      })
    }
  }
  
  return rows.length
}

async function notifyNextUser(equipmentId) {
  const next = await prisma.waitingQueue.findFirst({
    where: { equipmentId, status: 'WAITING' },
    orderBy: { queuePosition: 'asc' },
    include: { user: true, equipment: true },
  })
  
  if (!next) return false

  await prisma.waitingQueue.update({
    where: { id: next.id },
    data: { status: 'NOTIFIED', notifiedAt: new Date() },
  })

  // üî• Îã§Ïùå ÏÇ¨Ïö©Ïûê ÏïåÎ¶º (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
  sendNotification(next.userId, {
    type: 'EQUIPMENT_AVAILABLE',
    title: 'Í∏∞Íµ¨ ÏÇ¨Ïö© Í∞ÄÎä•',
    message: `${next.equipment.name}ÏùÑ ÏÇ¨Ïö©Ìï† Ï∞®Î°ÄÏûÖÎãàÎã§`,
    equipmentId,
    equipmentName: next.equipment.name,
    queueId: next.id,
    graceMinutes: 5,
  })

  // üî• ÎåÄÍ∏∞Ïó¥ Î≥ÄÍ≤Ω Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
  broadcastEquipmentStatusChange(equipmentId, {
    type: 'next_user_notified',
    equipmentName: next.equipment.name,
    nextUserName: next.user.name,
    queuePosition: next.queuePosition
  })

  // 5Î∂Ñ Ïú†Ïòà ÌÉÄÏù¥Î®∏
  setTimeout(async () => {
    const fresh = await prisma.waitingQueue.findUnique({ where: { id: next.id } })
    if (fresh && fresh.status === 'NOTIFIED') {
      await prisma.waitingQueue.update({ 
        where: { id: next.id }, 
        data: { status: 'EXPIRED' } 
      })
      
      sendNotification(next.userId, {
        type: 'QUEUE_EXPIRED',
        title: 'ÎåÄÍ∏∞ ÎßåÎ£å',
        message: 'ÏãúÍ∞Ñ Ï¥àÍ≥ºÎ°ú ÎåÄÍ∏∞ÏóêÏÑú Ï†úÏô∏ÎêòÏóàÏäµÎãàÎã§',
        equipmentId,
      })
      
      await reorderQueue(equipmentId)
      await notifyNextUser(equipmentId)
    }
  }, 5 * 60 * 1000)

  return true
}

// ====== Ï∂îÍ∞Ä APIÎì§ ======

// Ïã§ÏãúÍ∞Ñ ÏÉÅÌÉú Ï°∞Ìöå
router.get('/status/:equipmentId', async (req, res) => {
  try {
    const equipmentId = parseInt(req.params.equipmentId)
    const equipment = await prisma.equipment.findUnique({ where: { id: equipmentId } })
    if (!equipment) return res.status(404).json({ error: 'Í∏∞Íµ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§' })

    const currentUsage = await prisma.equipmentUsage.findFirst({
      where: { equipmentId, status: 'IN_USE' },
      include: { user: { select: { name: true } } }
    })
    
    const queue = await prisma.waitingQueue.findMany({
      where: { equipmentId, status: { in: ['WAITING', 'NOTIFIED'] } },
      orderBy: { queuePosition: 'asc' },
      include: { user: { select: { name: true } } }
    })

    const currentETA = currentUsage ? calculateRealTimeETA(currentUsage) : 0
    const queueETAs = buildQueueETAs(currentETA, queue)

    let setProgress = null
    if (currentUsage && currentUsage.setStatus === 'EXERCISING' && currentUsage.currentSetStartedAt) {
      const elapsed = Date.now() - currentUsage.currentSetStartedAt.getTime()
      const estimatedSetTime = AVG_SET_MIN * 60 * 1000
      setProgress = Math.min(100, Math.round((elapsed / estimatedSetTime) * 100))
    }

    res.json({
      equipmentId,
      equipmentName: equipment.name,
      isAvailable: !currentUsage,
      lastUpdated: new Date(),
      currentUser: currentUsage ? {
        name: currentUsage.user.name,
        startedAt: currentUsage.startedAt,
        totalSets: currentUsage.totalSets,
        currentSet: currentUsage.currentSet,
        setStatus: currentUsage.setStatus,
        restSeconds: currentUsage.restSeconds,
        progress: Math.round((currentUsage.currentSet / currentUsage.totalSets) * 100),
        setProgress,
        estimatedMinutesLeft: currentETA,
        restTimeLeft: currentUsage.setStatus === 'RESTING' && currentUsage.restStartedAt ? 
          Math.max(0, Math.ceil((currentUsage.restSeconds * 1000 - (Date.now() - currentUsage.restStartedAt.getTime())) / 1000)) : 0
      } : null,
      waitingQueue: queue.map((q, i) => ({
        id: q.id,
        position: q.queuePosition,
        userName: q.user.name,
        status: q.status,
        createdAt: q.createdAt,
        notifiedAt: q.notifiedAt,
        estimatedWaitMinutes: queueETAs[i] || 0,
      })),
      totalWaiting: queue.length,
      averageWaitTime: queue.length ? Math.round(queueETAs.reduce((a, b) => a + b, 0) / queue.length) : 0,
    })
  } catch (error) {
    console.error('ÏÉÅÌÉú Ï°∞Ìöå Ïò§Î•ò:', error)
    res.status(500).json({ error: 'ÏÉÅÌÉú Ï°∞ÌöåÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§' })
  }
})

// ÏãúÏä§ÌÖú ÌÜµÍ≥Ñ
router.get('/admin/stats', auth(), async (req, res) => {
  try {
    const activeUsages = await prisma.equipmentUsage.count({ 
      where: { status: 'IN_USE' } 
    })
    
    const activeQueues = await prisma.waitingQueue.count({ 
      where: { status: { in: ['WAITING', 'NOTIFIED'] } } 
    })
    
    res.json({
      activeUsages,
      activeQueues,
      autoUpdateCount: autoUpdateIntervals.size,
      rateLimitedUsers: userUpdateLimiter.size,
      timestamp: new Date()
    })
  } catch (error) {
    console.error('ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò:', error)
    res.status(500).json({ error: 'ÌÜµÍ≥Ñ Ï°∞Ìöå Ïã§Ìå®' })
  }
})

module.exports = { router }